#region license

/*
MediaFoundationLib - Provide access to MediaFoundation interfaces via .NET
Copyright (C) 2007
http://mfnet.sourceforge.net

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#endregion

using System;
using System.Collections;
using System.Text;
using System.Drawing;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;

using MediaFoundation.Misc;
using MediaFoundation.Transform;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Collections.Concurrent;

namespace MediaFoundation.Misc.Classes
{
    /// <summary>
    /// Class to marshal <see cref="PropVariant" /> on parameters that *output* PropVariants.
    /// </summary>
    /// <seealso cref="System.Runtime.InteropServices.ICustomMarshaler" />
    /// <remarks>
    /// When defining parameters that use this marshaller, you must always declare them
    /// as both [In] and [Out].  This will result in *both* MarshalManagedToNative and
    /// MarshalNativeToManaged being called.
    /// <para />
    /// Managed calling unmanaged:
    /// <para />
    /// In this case, MarshalManagedToNative is called first.
    /// When MarshalManagedToNative is called, we clear the variant, allocate native memory
    /// and store the mapping between the native memory address and the variant object in
    /// a global table. Because we've allocated the native memory, we are sure that the
    /// address is uniqie and the mapping can later be resolved unambiguisly. Finally, we
    /// pass a pointer to the native memory to the native code.  When the native code
    /// is done, MarshalNativeToManaged gets called with the pointer to the native memory.
    /// We use the native memory address to lookup the saved variant object in the global
    /// table so that we copy the contents back into the managed variant object. After
    /// that, CleanUpNativeData gets called and we release the native memory as weel as
    /// remove the mapping from the global table. The CLR guarantees that CleanUpNativeData
    /// will be called.
    /// <para />
    /// Unmanaged calling managed:
    /// <para/>
    /// In this case, MarshalNativeToManaged is called first containing the native memory
    /// pointer passed to the CLR from native code. We instantiate a managed a
    /// CallInPropVariant and copy the native value into it as well as the native memory
    /// address. CallInPropVariant as a subclass of PropVariant allowing is to store
    /// the additional native memory address as well as distinguish the call semantics,
    /// i.e. CLR to native or native to CLR. When the managed code is done,
    /// MarshalManagedToNative gets called with the managed CallInPropVariant we created.
    /// At that point, we copy the contents of the managed CallInPropVariant back into the
    /// native pointer, which we saved inside the CallInPropVariant.
    /// <para />
    /// Warning!  You cannot assume that both routines will always get called.  For example
    /// if calling from unmanaged to managed, MarshalNativeToManaged will get called, but
    /// if the managed code throws an exception, MarshalManagedToNative will not.  This
    /// can be a problem since .Net REUSES instances of the marshaller.  So it is essential
    /// that class members always get cleaned up in CleanUpManagedData and CleanUpNativeData.
    /// <para/>
    /// Below is an example of the marshaling code for a CLR to native call generated by the
    /// CLR for this method:
    /// <code>
    /// [PreserveSig]
    /// int GetPresentationAttribute(
    ///     int dwStreamIndex,
    ///     [In, MarshalAs(UnmanagedType.LPStruct)] Guid guidAttribute,
    ///     [In, Out, MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(PropVariantMarshaler), MarshalCookie = "IMFSourceReader.GetPresentationAttribute")] PropVariant pvarAttribute);
    /// </code>
    /// <code language="MSIL">
    /// // Managed Signature: instance int32(int32,valuetype [mscorlib]System.Guid,class MediaFoundation.PropVariant)
    /// // Native Signature: unmanaged stdcall int32(native int,int32,native int,native int)
    ///
    /// // IL Stub:
    /// // Code size    198 (0x00c6)
    /// .maxstack 5
    /// .locals(int32, native int, native int, bool, int32, native int, native int, native int, int32, int32, int32)
    /// // Initialize {
    /// /*( 0)*/
    ///                   ldc.i4          0x0   Push 0 onto the stack as int32.
    ///          /*( 1)*/ conv.i Convert to native int, pushing native int on stack.
    /// /*( 1)*/ stloc.2
    ///          /*( 0)*/ ldc.i4          0x4
    ///          /*( 1)*/ localloc
    ///          /*( 1)*/ stloc.s         0x6
    ///          /*( 0)*/ ldloc.s         0x6
    ///          /*( 1)*/ ldtoken instance int32[MediaFoundationEx] MediaFoundation.ReadWrite.Interfaces.IMFSourceReader::GetPresentationAttribute(int32, valuetype[mscorlib] System.Guid,class MediaFoundation.PropVariant)
    ///          /*( 2)*/ call native int[mscorlib] System.RuntimeMethodHandle::GetValueInternal(valuetype System.RuntimeMethodHandle)
    ///          /*( 2)*/ ldc.i4          0x8000237
    ///          /*( 3)*/ ldtoken MediaFoundation.PropVariant
    ///          /*( 4)*/ call native int[mscorlib] System.RuntimeTypeHandle::GetValueInternal(valuetype System.RuntimeTypeHandle)
    ///          /*( 4)*/ call native int[mscorlib] System.StubHelpers.StubHelpers::CreateCustomMarshalerHelper(native int, int32, native int)
    ///          /*( 2)*/ call void[mscorlib]
    ///     System.StubHelpers.MngdRefCustomMarshaler::CreateMarshaler(native int,native int)
    /// // } Initialize
    /// // Marshal {
    ///          /*( 0)*/ ldc.i4          0x0
    ///          /*( 1)*/ stloc.0
    /// IL_003b: /*( 0)*/ nop             // argument {
    ///                                   /*( 0)*/ ldarg.1
    ///          /*( 1)*/ stloc.s         0x4
    ///          /*( 0)*/ nop             // } argument
    ///                                   /*( 0)*/ nop             // argument {
    ///          /*( 0)*/ ldarga.s        0x2
    ///          /*( 1)*/ stloc.s         0x5
    ///          /*( 0)*/ nop             // } argument
    ///                                   /*( 0)*/ nop             // argument {
    ///          /*( 0)*/ ldloc.s         0x6
    ///          /*( 1)*/ ldarga.s        0x3
    ///          /*( 2)*/ ldloca.s        0x7
    ///          /*( 3)*/ call void[mscorlib]
    ///     System.StubHelpers.MngdRefCustomMarshaler::ConvertContentsToNative(native int,object&amp;,native int)
    ///          /*( 0)*/ ldc.i4          0x3
    ///          /*( 1)*/ stloc.0
    ///          /*( 0)*/ nop             // } argument
    ///                                   /*( 0)*/ nop             // return {
    ///          /*( 0)*/ nop             // } return
    ///                                   // } Marshal
    ///                                   // CallMethod {
    ///                                   /*( 0)*/ ldarg.0
    ///          /*( 1)*/ call native int[mscorlib] System.StubHelpers.StubHelpers::GetStubContext()
    ///          /*( 2)*/ ldloca.s        0x1
    ///          /*( 3)*/ ldloca.s        0x3
    ///          /*( 4)*/ call native int[mscorlib] System.StubHelpers.StubHelpers::GetCOMIPFromRCW(object, native int, native int&amp;, bool&amp;)
    ///          /*( 1)*/ dup
    ///          /*( 2)*/ stloc.2
    ///          /*( 1)*/ ldloc.s         0x4
    ///          /*( 2)*/ ldloc.s         0x5
    ///          /*( 3)*/ ldloc.s         0x7
    ///          /*( 4)*/ ldloc.1
    ///          /*( 5)*/ calli unmanaged stdcall int32(native int, int32, native int, native int)
    ///          /*( 1)*/ ldarg.0
    ///          /*( 2)*/ call void[mscorlib]
    ///     System.GC::KeepAlive(object)
    /// // } CallMethod
    /// // UnmarshalReturn {
    ///          /*( 1)*/ nop             // return {
    ///                                   /*( 1)*/ stloc.s         0x9
    ///          /*( 0)*/ ldloc.s         0x9
    ///          /*( 1)*/ stloc.s         0x8
    ///          /*( 0)*/ ldloc.s         0x8
    ///          /*( 1)*/ nop             // } return
    ///                                   /*( 1)*/ stloc.s         0xa
    /// // } UnmarshalReturn
    /// // Unmarshal {
    /// /*( 0)*/ nop             // argument {
    ///                                   /*( 0)*/ nop             // } argument
    ///          /*( 0)*/ nop             // argument {
    ///                                   /*( 0)*/ nop             // } argument
    ///          /*( 0)*/ nop             // argument {
    ///                                   /*( 0)*/ ldloc.s         0x6
    ///          /*( 1)*/ ldarga.s        0x3
    ///          /*( 2)*/ ldloca.s        0x7
    ///          /*( 3)*/ call            void[mscorlib] System.StubHelpers.MngdRefCustomMarshaler::ConvertContentsToManaged(native int, object&amp;, native int)
    ///          /*( 0)*/ nop             // } argument
    ///                                   /*( 0)*/ leave           IL_00a0
    /// IL_00a0: /*( 0)*/ ldloc.s         0xa
    ///          /*( 1)*/ ret
    /// // } Unmarshal
    /// // ExceptionCleanup {
    /// IL_00a3:
    /// // } ExceptionCleanup
    /// // Cleanup {
    ///          /*( 0)*/ ldloc.3
    ///          /*( 1)*/ brfalse IL_00af
    ///          /*( 0)*/ ldloc.2
    ///          /*( 1)*/ call void[mscorlib]
    ///     System.StubHelpers.InterfaceMarshaler::ClearNative(native int)
    /// IL_00af: /*( 0)*/ ldloc.0
    ///          /*( 1)*/ ldc.i4          0x2
    ///          /*( 2)*/ ble IL_00c5
    ///          /*( 0)*/ ldloc.s         0x6
    ///          /*( 1)*/ ldarga.s        0x3
    ///          /*( 2)*/ ldloca.s        0x7
    ///          /*( 3)*/ call void[mscorlib]
    ///     System.StubHelpers.MngdRefCustomMarshaler::ClearNative(native int,object&amp;,native int)
    /// IL_00c5: /*( 0)*/ endfinally
    /// IL_00c6:
    /// // } Cleanup
    /// .try IL_003b to IL_00a0 finally handler IL_00a3 to IL_00c6
    /// </code>
    /// <para/>
    /// <strong>** SPECIAL CASE - WHAT IF **</strong>
    /// <pre>
    /// ... a naive developer reused the CallInPropVariant inside a
    /// Native to CLR call to call with the same CallInPropVariant
    /// out from the CLR to Native again.
    ///
    /// NB: We don't expect native code to do similar calls and
    /// reuse the variant pointer passed to it.
    ///
    /// Example:
    /// 01. - [NativeCode]
    /// 02.      - MarshalNativeToManaged(IntPtr pNativeData)
    /// 03.          - ManagedCallBack(CallInPropVariant outputValue)
    /// 04.              ...
    /// 05.              - NativeAPI(PropVariant outputValue) --- BUT in here, they pass the value from above!!!
    /// 06.                  **** Special Case Start ****
    /// 07.                  -MarshalManagedToNative(CallInPropVariant obj)
    /// 08.                      - [Native Code]
    /// 09.                  - MarshalNativeToManaged(IntPtr pNativeData)
    /// 10.                  - CleanUpNativeData(IntPtr pNativeData)
    /// 11.                  **** Special Case End ****
    /// 12.              - NativeAPI(PropVariant outputValue) --- Back to the bad guy.
    /// 13.              ...
    /// 14.      - MarshalManagedToNative(CallInPropVariant obj)
    /// 15.      - CleanUpManagedData(object obj)
    /// 16. - [NativeCode]
    ///
    /// Issue is 07. Obviously, this not return from Native to CLR call
    /// but call to a call CLR to Native. But we cannot distinguish this,
    /// because we were passed CallInPropVariant, which we normally don't
    /// get here. Well, in this special case, we'll reuse the address
    /// passed to use in 02. The native code getting called doesn't care.
    ///
    /// The special case disturbs 09. and 10. Those handle this accordingly.
    ///
    /// To handle the SPECIAL CASE, we need to modify MarshalNativeToManaged to
    /// store mapping information, so that the second call to MarshalNativeToManaged
    /// and CleanUpNativeData do net get confused. This mapping is cleared
    /// in the CleanUpManagedData call.
    ///
    /// NB: To repeat! The reason this does not end up in a cycle is because
    /// we assume that native code will not call CLR code with a variant
    /// pointer that WE passed to native code!!!
    /// </pre>
    /// </remarks>
    internal class PropVariantMarshaler : ICustomMarshaler
    {
        /// <summary>
        /// The cookie for the API argument. We don't need this but keep it for diagnostic purposes.
        /// </summary>
        private readonly string Cookie;

        /// <summary>
        /// Initializes a new instance of the <see cref="PropVariantMarshaler"/> class.
        /// </summary>
        /// <param name="cookie">The marshal cookie for the API argument.</param>
        private PropVariantMarshaler(string cookie)
        {
            this.Cookie = cookie;
        }

        #region Declarations

        /// <summary>
        /// The PropVariantInit function initializes a <c>PROPVARIANT</c> structure.
        /// </summary>
        /// <param name="pvar">
        /// Pointer to an uninitialized PROPVARIANT structure that is initialized.
        /// </param>
        /// <remarks>
        /// Initializes a PROPVARIANT structure, and sets its type to VT_EMPTY.
        /// PropVariantInit should not be used to clear a PROPVARIANT structure that
        /// contains data; for example, when it contains the result of a call to
        /// IPropertyStorage::ReadMultiple. Such a PROPVARIANT structure should be
        /// cleared using the PropVariantClear function.
        /// <code language="cpp" title="C/C++ Syntax">
        /// void PropVariantInit(
        ///     _Out_ PROPVARIANT *pvar
        /// );
        /// </code>
        /// </remarks>
        private static void PropVariantInit(IntPtr pvar)
        {
            Marshal.WriteInt64(pvar, 0, 0);
            Marshal.WriteInt64(pvar, 8, 0);
        }

        /// <summary>
        /// Clears a <c>PROPVARIANT</c> structure.
        /// </summary>
        /// <param name="pvar">
        /// Type: <strong><c>PROPVARIANT</c>* </strong>
        /// <para/>
        /// Pointer to the <c>PROPVARIANT</c> structure to clear. When this function successfully returns, the
        /// <strong>PROPVARIANT</strong> is zeroed and the type is set to VT_EMPTY.
        /// </param>
        /// <remarks>
        /// <code language="cpp" title="C/C++ Syntax">
        /// HRESULT PropVariantClear(
        ///   _Inout_  PROPVARIANT *pvar
        /// );
        /// </code>
        /// <para/>
        /// The above documentation is © Microsoft Corporation. It is reproduced here
        /// with the sole purpose to increase usability and add IntelliSense support.
        /// <para/>
        /// View the original documentation topic online:
        /// <a href="http://msdn.microsoft.com/en-US/library/68B00E4B-39D3-49E3-8A0D-032EDCB23B06(v=VS.85,d=hv.2).aspx">http://msdn.microsoft.com/en-US/library/68B00E4B-39D3-49E3-8A0D-032EDCB23B06(v=VS.85,d=hv.2).aspx</a>
        /// </remarks>
        [DllImport("ole32.dll", ExactSpelling = true, PreserveSig = false)]
        [SuppressUnmanagedCodeSecurity]
        protected static extern void PropVariantClear(
            IntPtr pvar);

        #endregion

        #region ICustomMarshaler interface

        private static readonly ConcurrentDictionary<IntPtr, PropVariant> ManagedNativeMap = new ConcurrentDictionary<IntPtr, PropVariant>();

        private static readonly ConcurrentDictionary<IntPtr, CallInPropVariant> NativeManagedMap = new ConcurrentDictionary<IntPtr, CallInPropVariant>();

        /// <summary>
        /// Converts the managed data to unmanaged data.
        /// </summary>
        /// <param name="managedObj">The managed object to be converted.</param>
        /// <returns>A pointer to the native view of the managed object.</returns>
        public IntPtr MarshalManagedToNative(object managedObj)
        {
            // Nulls don't invoke custom marshalling.
            if (managedObj == null)
                return IntPtr.Zero;
            if (!(managedObj is PropVariant))
                throw new AggregateException("PropVariantMarshaler may only be used to marshal PropVariant objects.");

            if (!(managedObj is CallInPropVariant))
            {
                // CLR to Native call

                PropVariant variant = (PropVariant)managedObj;

                // Release any memory currently allocated in the
                // PropVariant.  In theory, the (managed) caller should
                // have done this before making the call that got us
                // here, but .Net programmers don't generally think that
                // way.  To avoid any leaks, do it for them.
                variant.Clear();

                // Create an appropriately sized buffer (varies from
                // x86 to x64).
                int iSize = Marshal.SizeOf(typeof(PropVariant));
                IntPtr nativeAddress = Marshal.AllocCoTaskMem(iSize);

                // For out parameters, this should not be necessary,
                // but by doing this we can save us a lot of headache.
                PropVariantMarshaler.PropVariantInit(nativeAddress);

                // Store the mapping between the native address and the managed
                // object in the global NativeManagedMap table.
                PropVariantMarshaler.ManagedNativeMap.AddOrUpdate(nativeAddress, variant, (na, v) => v);

                // Returnt the native address, so it can be passed to the native API.
                return nativeAddress;
            }
            else
            {
                // Native to CLR.
                CallInPropVariant variant = (CallInPropVariant)managedObj;

                // ** SPECIAL CASE - WHAT IF **
                // ... a naive developer reused the CallInPropVariant inside a
                // Native to CLR call to call with the same CallInPropVariant
                // out from the CLR to Native again.
                //
                // NB: We don't expect native code to do similar calls and
                // reuse the variant pointer passed to it.
                //
                // Example:
                // 01. - [NativeCode]
                // 02.      - MarshalNativeToManaged(IntPtr pNativeData)
                // 03.          - ManagedCallBack(CallInPropVariant outputValue)
                // 04.              ...
                // 05.              - NativeAPI(PropVariant outputValue) <== BUT in here, they pass the value from above!!!
                // 06.                  **** Special Case Start ****
                // 07.                  -MarshalManagedToNative(CallInPropVariant obj)
                // 08.                      - [Native Code]
                // 09.                  - MarshalNativeToManaged(IntPtr pNativeData)
                // 10.                  - CleanUpNativeData(IntPtr pNativeData)
                // 11.                  **** Special Case End ****
                // 12.              - NativeAPI(PropVariant outputValue) <== Back to the bad guy.
                // 13.              ...
                // 14.      - MarshalManagedToNative(CallInPropVariant obj)
                // 15.      - CleanUpManagedData(object obj)
                // 16. - [NativeCode]
                //
                // Issue is 07. Obviously, this not return from Native to CLR call
                // but call to a call CLR to Native. But we cannot distinguish this,
                // because we were passed CallInPropVariant, which we normally don't
                // get here. Well, in this special case, we'll reuse the address
                // passed to use in 02. The native code getting called doesn't care.
                //
                // The special case disturbs 09. and 10. Those handle this accordingly.
                //
                // To handle the SPECIAL CASE, we need to modify MarshalNativeToManaged to
                // store mapping information, so that the second call to MarshalNativeToManaged
                // and CleanUpNativeData do net get confused. This mapping is cleared
                // in the CleanUpManagedData call.
                //
                // NB: To repeat! The reason this does not end up in a cycle is because
                // we assume that native code will not call CLR code with a variant
                // pointer that WE passed to native code!!!

                // Copy the data from the managed object into the native
                // pointer that we received in MarshalNativeToManaged.
                variant.CopyToNativeAddress();

                //Return the native address stored earlier in the variant.
                return variant.NativeAddress;
            }
        }

        /// <summary>
        /// Converts the unmanaged data to managed data.
        /// </summary>
        /// <param name="pNativeData">A pointer to the unmanaged data to be wrapped.</param>
        /// <returns>An object that represents the managed view of the native data.</returns>
        public object MarshalNativeToManaged(IntPtr pNativeData)
        {
            if (pNativeData == IntPtr.Zero)
                return null;

            // Are we returning from Native API call?

            PropVariant variant = null;
            PropVariantMarshaler.ManagedNativeMap.TryGetValue(pNativeData, out variant);
            if (variant != null)
            {
                // This is a CLR to Native call. We are in the unmarshal phase.
                // See also MarshalManagedToNative

                // Copy the data from the native pointer into the managed
                // object that we received in MarshalManagedToNative.
                Marshal.PtrToStructure(pNativeData, variant);

                return variant;
            }
            else
            {
                // This is a Native to CLR call.

                // See the SPECIAL CASE in  the comments.
                CallInPropVariant callInVariant = null;
                PropVariantMarshaler.NativeManagedMap.TryGetValue(pNativeData, out callInVariant);
                if (callInVariant != null)
                {
                    // Special case ... this is still return CLR to Native.
                    callInVariant.CopyToNativeAddress();
                    return callInVariant;
                }

                // ... Native to CLR!
                // Just in case we forget something, let's clean up!
                // Because the call is [out], it's safe here to init the variant
                // already here, so that we know that we can handle it cleanly.
                PropVariantMarshaler.PropVariantInit(pNativeData);

                // Create a CallInPropVariant, which contains a copy of the
                // contents of pNativeData as well as storing pNativeData.
                callInVariant = new CallInPropVariant(pNativeData);

                // Store information about the SPECIAL CASE described in the comments.
                PropVariantMarshaler.NativeManagedMap.AddOrUpdate(pNativeData, callInVariant, (na, v) => v);

                return callInVariant;
            }
        }

        /// <summary>
        /// Performs necessary cleanup of the managed data when it is no longer needed.
        /// </summary>
        /// <param name="managedObj">The managed object to be destroyed.</param>
        public void CleanUpManagedData(object managedObj)
        {
            // Must clean-up global mapping table (see warning at top of class).

            // See the SPECIAL CASE description in the class comments.
            CallInPropVariant variant = managedObj as CallInPropVariant;
            if (variant != null)
                PropVariantMarshaler.NativeManagedMap.TryRemove(variant.NativeAddress, out variant);
        }

        /// <summary>
        /// Performs necessary cleanup of the unmanaged data when it is no longer needed.
        /// </summary>
        /// <param name="pNativeData">A pointer to the unmanaged data to be destroyed.</param>
        public void CleanUpNativeData(IntPtr pNativeData)
        {
            if (pNativeData == IntPtr.Zero)
                return;

            // Must remove mapping from gloval table (see remarks at top of class).
            PropVariant na;
            if (PropVariantMarshaler.ManagedNativeMap.TryRemove(pNativeData, out na))
            {
                // Because of the SPECIAL CASE described in the comments,
                // we do not always free the native memory!!! Only if this is
                // real CLR to Native call, not one where the VARINT passed from
                // Native code to CLR was reused to do a native call again.

                // Free the memory we allocated in MarshalManagedToNative.
                Marshal.FreeCoTaskMem(pNativeData);
            }
        }

        /// <summary>
        /// Returns the size of the native data to be marshaled.
        /// </summary>
        /// <returns>The size, in bytes, of the native data.</returns>
        public int GetNativeDataSize()
        {
            // -1 for all reference types. Only used for value types (currently not supported by the CLR).
            return -1;
        }

        /// <summary>
        /// This method is called by interop to create the custom marshaler.
        /// </summary>
        /// <param name="cookie">
        /// The (optional) cookie is the value specified in MarshalCookie="asdf", or "" if none is specified.
        /// </param>
        /// <remarks>
        /// This is not techically part of the ICustomMarshaler interface, but must be implemented as well.
        /// The CLR can call this even if the method is private.
        /// </remarks>
        private static ICustomMarshaler GetInstance(string cookie)
        {
            return new PropVariantMarshaler(cookie);
        }

        #endregion

        private class CallInPropVariant : PropVariant
        {
            public IntPtr NativeAddress;

            public CallInPropVariant(IntPtr nativeAddress)
            {
                // Store the native address for later use by the marshaler.
                this.NativeAddress = nativeAddress;

                // NB: This is used as an output parameter, therefore
                // DO NOT copy the nativeAddress into our contents
                // (it may contain garbage).

                // Clean-up is the responsibility of the caller.
                GC.SuppressFinalize(this);
            }

            private void CopyFromNativeAddress()
            {
                // Unfortunately, we can't use Marshal.PtrToStructure,
                // because CallInPropVariant is larger than PropVariant
                // and if unlucky, NativeAddress may be at the end of a
                // the memory page and we may end up reading a protected
                // memory page and GPF. Copy by hand!
                this.type = (VariantType)Marshal.ReadInt16(this.NativeAddress, 0);
                this.reserved1 = Marshal.ReadInt16(this.NativeAddress, 2);
                this.reserved2 = Marshal.ReadInt16(this.NativeAddress, 4);
                this.reserved3 = Marshal.ReadInt16(this.NativeAddress, 6);
                this.longValue = Marshal.ReadInt64(this.NativeAddress, 8);
            }

            public void CopyToNativeAddress()
            {
                // Clear the existing variang before overwriting it.
                // It's safe to clear it, because we've ensured in
                // MarshalNativeToManaged that it properly initialized.
                PropVariantMarshaler.PropVariantClear(this.NativeAddress);

                // Unfortunately, we can't use Marshal.StructureToPtr,
                // because CallInPropVariant is larger than PropVariant
                // and if unlucky, NativeAddress may be at the end of a
                // the memory page and we may end up reading a protected
                // memory page and GPF. Copy by hand!
                Marshal.WriteInt16(this.NativeAddress, 0, (Int16)this.type);
                Marshal.WriteInt16(this.NativeAddress, 2, this.reserved1);
                Marshal.WriteInt16(this.NativeAddress, 4, this.reserved2);
                Marshal.WriteInt16(this.NativeAddress, 6, this.reserved3);
                Marshal.WriteInt64(this.NativeAddress, 8, this.longValue);
            }

            /// <summary>
            /// Releases unmanaged and - optionally - managed resources.
            /// </summary>
            /// <param name="disposing">
            /// <c>true</c> to release both managed and unmanaged resources;
            /// <c>false</c> to release only unmanaged resources.
            /// </param>
            protected override void Dispose(bool disposing)
            {
                // Do nothing. In this type of variant, clean-up is the responsibility
                // of the caller.
            }
        }
    }

    // Class to release PropVariants on parameters that output PropVariants.  There
    // should be no reason for code to call this class directly.  It is invoked
    // automatically when the appropriate methods are called.
    internal class XPropVariantMarshaler : ICustomMarshaler
    {
        //public static readonly System.Collections.Generic.List<DebugInfo> DebugInfos = new System.Collections.Generic.List<DebugInfo>();

        //public static void AddDebug(PropVariantMarshaler self, object obj, string op, IntPtr info)
        //{
        //    lock (SyncLock)
        //    {
        //        DebugInfos.Add(new DebugInfo()
        //        {
        //            ObjectId = (obj == null) ? 0 : obj.GetHashCode(),
        //            MarshlerId = self.GetHashCode(),
        //            Operation = op,
        //            ThreadId = System.Threading.Thread.CurrentThread.ManagedThreadId,
        //            Info = info
        //        });
        //    }
        //}

        //private static readonly object SyncLock = new object();

        //public struct DebugInfo
        //{
        //    public int ObjectId;
        //    public int MarshlerId;
        //    public string Operation;
        //    public int ThreadId;
        //    public IntPtr Info;
        //}

        // The managed object passed in to MarshalManagedToNative
        protected PropVariant m_prop;

        public IntPtr MarshalManagedToNative(object managedObj)
        {
            IntPtr p;

            //AddDebug(this, this.m_prop, "MarshalManagedToNative", (IntPtr)((managedObj == null) ? 0 : managedObj.GetHashCode()));

            // Cast the object back to a PropVariant
            this.m_prop = managedObj as PropVariant;

            if (this.m_prop != null)
            {
                // Release any memory currently allocated
                this.m_prop.Clear();

                // Create an appropriately sized buffer, blank it, and send it to
                // the marshaler to make the COM call with.
                int iSize = this.GetNativeDataSize();
                p = Marshal.AllocCoTaskMem(iSize);

                if (IntPtr.Size == 4)
                {
                    Marshal.WriteInt64(p, 0);
                    Marshal.WriteInt64(p, 8, 0);
                }
                else
                {
                    Marshal.WriteInt64(p, 0);
                    Marshal.WriteInt64(p, 8, 0);
                    Marshal.WriteInt64(p, 16, 0);
                }
            }
            else
            {
                p = IntPtr.Zero;
            }

            return p;
        }

        // Called just after invoking the COM method.  The IntPtr is the same one that just got returned
        // from MarshalManagedToNative.  The return value is unused.
        public object MarshalNativeToManaged(IntPtr pNativeData)
        {
            //AddDebug(this, this.m_prop, "MarshalNativeToManaged", pNativeData);

            Marshal.PtrToStructure(pNativeData, this.m_prop);
            this.m_prop = null;

            return this.m_prop;
        }

        public void CleanUpManagedData(object managedObj)
        {
            //AddDebug(this, this.m_prop, "CleanUpManagedData", (IntPtr)((managedObj == null) ? 0 : managedObj.GetHashCode()));
            this.m_prop = null;
        }

        public void CleanUpNativeData(IntPtr pNativeData)
        {
            //AddDebug(this, this.m_prop, "CleanUpNativeData", pNativeData);
            Marshal.FreeCoTaskMem(pNativeData);
        }

        // The number of bytes to marshal out
        public int GetNativeDataSize()
        {
            //AddDebug(this, this.m_prop, "GetNativeDataSize", IntPtr.Zero);
            return Marshal.SizeOf(typeof(PropVariant));
        }

        // This method is called by interop to create the custom marshaler.  The (optional)
        // cookie is the value specified in MarshalCookie="asdf", or "" is none is specified.
        public static ICustomMarshaler GetInstance(string cookie)
        {
            return new XPropVariantMarshaler();
        }
    }
}
